//! Zig Code Generator for AOT Compilation
//!
//! This module generates Zig source code from the IR representation.
//! The generated code can then be compiled by the Zig compiler to produce
//! native executables.
//!
//! ## Design
//!
//! The code generator translates IR instructions to Zig code that calls
//! runtime library functions. This approach:
//! - Leverages Zig's cross-compilation capabilities
//! - Avoids external dependencies like LLVM
//! - Produces readable, debuggable intermediate code
//!
//! ## Generated Code Structure
//!
//! ```zig
//! const std = @import("std");
//! const runtime = @import("runtime_lib.zig");
//!
//! // User-defined functions
//! fn php_user_func(...) *runtime.PHPValue { ... }
//!
//! // Main entry point
//! pub fn main() !void {
//!     runtime.initRuntime();
//!     defer runtime.deinitRuntime();
//!     php_main();
//! }
//!
//! fn php_main() void {
//!     // Generated PHP code
//! }
//! ```

const std = @import("std");
const Allocator = std.mem.Allocator;
const IR = @import("ir.zig");
const Diagnostics = @import("diagnostics.zig");
const DiagnosticEngine = Diagnostics.DiagnosticEngine;
const SourceLocation = Diagnostics.SourceLocation;

/// Zig Code Generator
/// Transforms IR modules into Zig source code
pub const ZigCodeGenerator = struct {
    allocator: Allocator,
    /// Output buffer for generated code
    output: std.ArrayListUnmanaged(u8),
    /// Current indentation level
    indent_level: u32,
    /// Set of runtime functions that need to be imported
    runtime_imports: std.StringHashMapUnmanaged(void),
    /// Diagnostics engine for error reporting
    diagnostics: ?*DiagnosticEngine,
    /// Current module being generated
    current_module: ?*const IR.Module,
    /// Map of block labels to generated labels
    block_labels: std.StringHashMapUnmanaged([]const u8),
    /// Counter for generating unique labels
    label_counter: u32,
    /// Track which registers have been declared
    declared_registers: std.AutoHashMapUnmanaged(u32, void),
    /// Track visited blocks to prevent infinite recursion
    visited_blocks: std.StringHashMapUnmanaged(void),

    /// Stack of loop condition labels for proper continue/break handling
    loop_stack: std.ArrayListUnmanaged(LoopContext),

    const Self = @This();

    /// Context for tracking loop structures
    const LoopContext = struct {
        /// Label of the condition block (for continue)
        cond_label: []const u8,
        /// Label of the exit block (for break)
        exit_label: []const u8,
    };

    /// Initialize a new code generator
    pub fn init(allocator: Allocator, diagnostics: ?*DiagnosticEngine) Self {
        return .{
            .allocator = allocator,
            .output = .{},
            .indent_level = 0,
            .runtime_imports = .{},
            .diagnostics = diagnostics,
            .current_module = null,
            .block_labels = .{},
            .label_counter = 0,
            .declared_registers = .{},
            .visited_blocks = .{},
            .loop_stack = .{},
        };
    }

    /// Deinitialize and free resources
    pub fn deinit(self: *Self) void {
        self.output.deinit(self.allocator);
        self.runtime_imports.deinit(self.allocator);
        self.block_labels.deinit(self.allocator);
        self.declared_registers.deinit(self.allocator);
        self.visited_blocks.deinit(self.allocator);
        self.loop_stack.deinit(self.allocator);
    }

    /// Generate Zig source code from an IR module
    /// Returns the generated source code as a string
    pub fn generate(self: *Self, module: *const IR.Module) ![]const u8 {
        self.current_module = module;

        // Clear previous state
        self.output.clearRetainingCapacity();
        self.runtime_imports.clearRetainingCapacity();
        self.block_labels.clearRetainingCapacity();
        self.label_counter = 0;
        self.loop_stack.clearRetainingCapacity();

        // Generate file header
        try self.generateHeader(module);

        // Generate runtime imports
        try self.generateRuntimeImports();

        // Generate global variables
        try self.generateGlobals(module);

        // Generate all functions
        for (module.functions.items) |func| {
            try self.generateFunction(func);
        }

        // Generate main entry point
        try self.generateMainEntry(module);

        return self.output.toOwnedSlice(self.allocator);
    }

    /// Generate file header with imports
    fn generateHeader(self: *Self, module: *const IR.Module) !void {
        try self.writeLine("//! Auto-generated Zig code from PHP source");
        try self.write("//! Source: ");
        try self.write(module.source_file);
        try self.writeLine("");
        try self.writeLine("//! Generated by zig-php AOT compiler");
        try self.writeLine("");
        try self.writeLine("const std = @import(\"std\");");
        try self.writeLine("const runtime = @import(\"runtime_lib.zig\");");
        try self.writeLine("");
    }

    /// Generate runtime library imports based on used functions
    fn generateRuntimeImports(self: *Self) !void {
        // The runtime module is already imported in the header
        // This function can be extended to generate specific imports
        // or type aliases if needed
        try self.writeLine("// Runtime type aliases");
        try self.writeLine("const PHPValue = runtime.PHPValue;");
        try self.writeLine("const PHPArray = runtime.PHPArray;");
        try self.writeLine("const PHPString = runtime.PHPString;");
        try self.writeLine("");
    }

    /// Generate global variable declarations
    fn generateGlobals(self: *Self, module: *const IR.Module) !void {
        if (module.globals.items.len == 0) return;

        try self.writeLine("// Global variables");
        for (module.globals.items) |global| {
            try self.write("var ");
            try self.write(global.name);
            try self.write(": ");
            try self.writeType(global.type_);
            try self.writeLine(" = undefined;");
        }
        try self.writeLine("");
    }

    /// Generate a function definition
    fn generateFunction(self: *Self, func: *const IR.Function) !void {
        // Clear per-function state
        self.declared_registers.clearRetainingCapacity();
        self.block_labels.clearRetainingCapacity();
        self.visited_blocks.clearRetainingCapacity();
        self.loop_stack.clearRetainingCapacity();

        // Generate function signature
        try self.write("fn ");
        try self.writeFunctionName(func.name);
        try self.write("(");

        // Generate parameters - always use *PHPValue for PHP functions
        for (func.params.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write("param_");
            try self.sanitizeVarName(param.name);
            try self.write(": *PHPValue");
        }

        try self.write(") ");
        // PHP functions always return *PHPValue (or void for procedures)
        if (func.return_type == .void) {
            try self.write("void");
        } else {
            try self.write("*PHPValue");
        }
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate local variable declarations for registers
        try self.generateRegisterDeclarations(func);

        // Generate parameter initialization - copy parameters to their corresponding registers
        if (func.params.items.len > 0) {
            try self.writeIndent();
            try self.writeLine("// Initialize parameters");
            for (func.params.items, 0..) |param, i| {
                // Find the register that corresponds to this parameter
                // Parameters are typically stored in the first N registers
                try self.writeIndent();
                try self.write("r");
                try self.writeInt(@intCast(i));
                try self.write(" = param_");
                try self.sanitizeVarName(param.name);
                try self.writeLine(";");
            }
            try self.writeLine("");
        }

        // Only generate the entry block - other blocks will be inlined by control flow
        if (func.blocks.items.len > 0) {
            try self.generateBasicBlock(func.blocks.items[0], true);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
        try self.writeLine("");
    }

    /// Generate register declarations at the start of a function
    fn generateRegisterDeclarations(self: *Self, func: *const IR.Function) !void {
        // Collect all registers used in the function
        var max_reg: u32 = 0;
        for (func.blocks.items) |block| {
            for (block.instructions.items) |inst| {
                if (inst.result) |reg| {
                    if (reg.id >= max_reg) {
                        max_reg = reg.id + 1;
                    }
                }
            }
        }

        if (max_reg > 0) {
            try self.writeIndent();
            try self.writeLine("// Local registers");
            for (0..max_reg) |i| {
                try self.writeIndent();
                try self.write("var r");
                try self.writeInt(@intCast(i));
                try self.writeLine(": *PHPValue = undefined;");
            }
            // Suppress unused variable warnings by using _ = rN;
            try self.writeIndent();
            try self.writeLine("// Suppress unused variable warnings");
            for (0..max_reg) |i| {
                try self.writeIndent();
                try self.write("_ = &r");
                try self.writeInt(@intCast(i));
                try self.writeLine(";");
            }
            try self.writeLine("");
        }
    }

    /// Generate a basic block
    fn generateBasicBlock(self: *Self, block: *const IR.BasicBlock, is_entry: bool) !void {
        // Generate block label (skip for entry block)
        if (!is_entry) {
            // Decrease indent for label
            if (self.indent_level > 0) {
                self.indent_level -= 1;
            }
            try self.writeIndent();
            try self.write("// Block: ");
            try self.writeLine(block.label);
            self.indent_level += 1;
        }

        // Generate instructions
        for (block.instructions.items) |inst| {
            try self.generateInstruction(inst);
        }

        // Generate terminator
        if (block.terminator) |term| {
            try self.generateTerminator(term);
        }
    }

    /// Generate code for a single instruction
    fn generateInstruction(self: *Self, inst: *const IR.Instruction) !void {
        try self.writeIndent();

        switch (inst.op) {
            // Constants
            .const_int => |val| try self.generateConstInt(inst.result, val),
            .const_float => |val| try self.generateConstFloat(inst.result, val),
            .const_bool => |val| try self.generateConstBool(inst.result, val),
            .const_string => |id| try self.generateConstString(inst.result, id),
            .const_null => try self.generateConstNull(inst.result),

            // Arithmetic operations
            .add => |op| try self.generateBinaryOp(inst.result, "php_add", op),
            .sub => |op| try self.generateBinaryOp(inst.result, "php_sub", op),
            .mul => |op| try self.generateBinaryOp(inst.result, "php_mul", op),
            .div => |op| try self.generateBinaryOp(inst.result, "php_div", op),
            .mod => |op| try self.generateBinaryOp(inst.result, "php_mod", op),
            .neg => |op| try self.generateUnaryOp(inst.result, "php_neg", op),
            .pow => |op| try self.generateBinaryOp(inst.result, "php_pow", op),

            // Comparison operations
            .eq => |op| try self.generateBinaryOp(inst.result, "php_eq", op),
            .ne => |op| try self.generateBinaryOp(inst.result, "php_ne", op),
            .lt => |op| try self.generateBinaryOp(inst.result, "php_lt", op),
            .le => |op| try self.generateBinaryOp(inst.result, "php_le", op),
            .gt => |op| try self.generateBinaryOp(inst.result, "php_gt", op),
            .ge => |op| try self.generateBinaryOp(inst.result, "php_ge", op),
            .identical => |op| try self.generateBinaryOp(inst.result, "php_identical", op),
            .not_identical => |op| try self.generateBinaryOp(inst.result, "php_not_identical", op),
            .spaceship => |op| try self.generateBinaryOp(inst.result, "php_spaceship", op),

            // Logical operations
            .and_ => |op| try self.generateLogicalAnd(inst.result, op),
            .or_ => |op| try self.generateLogicalOr(inst.result, op),
            .not => |op| try self.generateLogicalNot(inst.result, op),

            // String operations
            .concat => |op| try self.generateBinaryOp(inst.result, "php_string_concat", op),
            .strlen => |op| try self.generateStrlen(inst.result, op),

            // Array operations
            .array_new => |op| try self.generateArrayNew(inst.result, op),
            .array_get => |op| try self.generateArrayGet(inst.result, op),
            .array_set => |op| try self.generateArraySet(op),
            .array_push => |op| try self.generateArrayPush(op),
            .array_count => |op| try self.generateArrayCount(inst.result, op),

            // Function calls
            .call => |op| try self.generateCall(inst.result, op),

            // Memory operations
            .alloca => |op| try self.generateAlloca(inst.result, op),
            .store => |op| try self.generateStore(op),
            .load => |op| try self.generateLoad(inst.result, op),
            .retain => |op| try self.generateRetain(op),
            .release => |op| try self.generateRelease(op),

            // Box/Unbox operations
            .box => |op| try self.generateBox(inst.result, op),
            .unbox => |op| try self.generateUnbox(inst.result, op),

            // Other operations - generate placeholder or skip
            else => {
                try self.write("// TODO: ");
                try self.write(@tagName(inst.op));
                try self.writeLine("");
                return;
            },
        }
    }

    /// Check if a block eventually branches back to a target block (loop detection)
    fn blockLoopsBackTo(self: *Self, block: *const IR.BasicBlock, target_label: []const u8, depth: u32) bool {
        if (depth > 10) return false; // Prevent infinite recursion

        if (block.terminator) |term| {
            switch (term) {
                .br => |next_block| {
                    if (std.mem.eql(u8, next_block.label, target_label)) return true;
                    return self.blockLoopsBackTo(next_block, target_label, depth + 1);
                },
                .cond_br => |cb| {
                    // Check if either branch loops back
                    if (std.mem.eql(u8, cb.then_block.label, target_label)) return true;
                    if (std.mem.eql(u8, cb.else_block.label, target_label)) return true;
                    // Recursively check
                    if (self.blockLoopsBackTo(cb.then_block, target_label, depth + 1)) return true;
                    if (self.blockLoopsBackTo(cb.else_block, target_label, depth + 1)) return true;
                    return false;
                },
                else => return false,
            }
        }
        return false;
    }

    /// Check if we're currently inside a loop
    fn isInsideLoop(self: *const Self) bool {
        return self.loop_stack.items.len > 0;
    }

    /// Check if a label is a loop condition we're currently inside
    fn isCurrentLoopCondition(self: *const Self, label: []const u8) bool {
        for (self.loop_stack.items) |ctx| {
            if (std.mem.eql(u8, ctx.cond_label, label)) return true;
        }
        return false;
    }

    /// Check if a label is a loop exit we're currently inside
    fn isCurrentLoopExit(self: *const Self, label: []const u8) bool {
        for (self.loop_stack.items) |ctx| {
            if (std.mem.eql(u8, ctx.exit_label, label)) return true;
        }
        return false;
    }

    /// Detect if a conditional branch represents a loop structure
    fn isLoopCondition(self: *Self, then_block: *const IR.BasicBlock) bool {
        // A loop is detected when:
        // 1. The then_block eventually branches back to a condition block
        // 2. The else_block is the exit
        
        // Check if then_block eventually loops back
        if (then_block.terminator) |then_term| {
            switch (then_term) {
                .br => |next| {
                    // Direct branch back - check if it's to a condition block
                    if (std.mem.startsWith(u8, next.label, "for_cond") or
                        std.mem.startsWith(u8, next.label, "while_cond") or
                        std.mem.startsWith(u8, next.label, "foreach_cond") or
                        std.mem.startsWith(u8, next.label, "range_cond"))
                    {
                        return true;
                    }
                    // Check if it branches to a loop block that then branches to condition
                    if (std.mem.startsWith(u8, next.label, "for_loop")) {
                        return true;
                    }
                },
                .cond_br => {
                    // Nested condition - could still be a loop with break/continue
                    return self.blockLoopsBackTo(then_block, then_block.label, 0);
                },
                else => {},
            }
        }
        return false;
    }

    /// Find the merge block that both branches of an if/else converge to
    /// This handles nested if/else chains (elseif) by recursively finding the ultimate merge point
    fn findMergeBlock(self: *Self, then_block: *const IR.BasicBlock, else_block: *const IR.BasicBlock) ?*const IR.BasicBlock {
        _ = self;
        // Get the target of the then branch
        const then_target = if (then_block.terminator) |t| switch (t) {
            .br => |b| b,
            else => null,
        } else null;
        
        // If then_target is a merge block, return it
        if (then_target != null and std.mem.startsWith(u8, then_target.?.label, "if_merge")) {
            return then_target;
        }
        
        // For the else branch, check if it's a direct branch or a nested conditional
        if (else_block.terminator) |t| {
            switch (t) {
                .br => |b| {
                    // Direct branch - check if it goes to the same place as then
                    if (then_target != null and std.mem.eql(u8, b.label, then_target.?.label)) {
                        return then_target;
                    }
                },
                .cond_br => {
                    // Nested conditional (elseif) - the merge block is where then goes
                    // because all branches of the elseif chain should merge there
                    return then_target;
                },
                else => {},
            }
        }
        
        return null;
    }
    
    /// Generate an if/else or elseif chain, with optional merge block generation
    /// When is_nested is true, we don't generate the merge block (the outer call will do it)
    fn generateIfElseWithMerge(self: *Self, cb: anytype, is_nested: bool) error{OutOfMemory}!void {
        // Find the merge block
        const merge_block = self.findMergeBlock(cb.then_block, cb.else_block);
        
        try self.writeIndent();
        try self.write("if (runtime.php_value_to_bool(r");
        try self.writeInt(cb.cond.id);
        try self.writeLine(")) {");
        self.indent_level += 1;
        
        // Generate then block
        if (self.visited_blocks.get(cb.then_block.label) == null) {
            try self.visited_blocks.put(self.allocator, cb.then_block.label, {});
            for (cb.then_block.instructions.items) |inst| {
                try self.generateInstruction(inst);
            }
            // Don't follow the terminator if it goes to merge block
            if (cb.then_block.terminator) |then_term| {
                switch (then_term) {
                    .br => |br_block| {
                        if (merge_block == null or !std.mem.eql(u8, br_block.label, merge_block.?.label)) {
                            try self.generateTerminator(then_term);
                        }
                    },
                    else => try self.generateTerminator(then_term),
                }
            }
        }
        
        self.indent_level -= 1;
        try self.writeIndent();
        try self.writeLine("} else {");
        self.indent_level += 1;
        
        // Generate else block
        if (self.visited_blocks.get(cb.else_block.label) == null) {
            try self.visited_blocks.put(self.allocator, cb.else_block.label, {});
            for (cb.else_block.instructions.items) |inst| {
                try self.generateInstruction(inst);
            }
            // Check if the else block's terminator is another conditional (elseif)
            if (cb.else_block.terminator) |else_term| {
                switch (else_term) {
                    .cond_br => |nested_cb| {
                        // This is an elseif - generate it as nested (don't generate merge block)
                        try self.generateIfElseWithMerge(nested_cb, true);
                    },
                    .br => |br_block| {
                        if (merge_block == null or !std.mem.eql(u8, br_block.label, merge_block.?.label)) {
                            try self.generateTerminator(else_term);
                        }
                    },
                    else => try self.generateTerminator(else_term),
                }
            }
        }
        
        self.indent_level -= 1;
        try self.writeIndent();
        try self.writeLine("}");
        
        // Only generate the merge block if we're not nested (i.e., we're the outermost if/else)
        if (!is_nested) {
            if (merge_block) |merge| {
                if (self.visited_blocks.get(merge.label) == null) {
                    try self.visited_blocks.put(self.allocator, merge.label, {});
                    for (merge.instructions.items) |inst| {
                        try self.generateInstruction(inst);
                    }
                    if (merge.terminator) |merge_term| {
                        try self.generateTerminator(merge_term);
                    }
                }
            }
        }
    }

    /// Generate terminator code
    fn generateTerminator(self: *Self, term: IR.Terminator) !void {
        switch (term) {
            .ret => |val| {
                try self.writeIndent();
                if (val) |reg| {
                    try self.write("return r");
                    try self.writeInt(reg.id);
                    try self.writeLine(";");
                } else {
                    try self.writeLine("return;");
                }
            },
            .br => |block| {
                // Check if this is a branch to a loop condition (continue)
                if (self.isCurrentLoopCondition(block.label)) {
                    // This is a continue - the while loop will handle re-evaluation
                    return;
                }
                
                // Check if this is a branch to a loop exit (break)
                if (self.isCurrentLoopExit(block.label)) {
                    try self.writeIndent();
                    try self.writeLine("break;");
                    return;
                }
                
                // Check if this is a branch to a for_loop block (increment)
                // If so, generate the increment and then the condition re-evaluation
                if (std.mem.startsWith(u8, block.label, "for_loop")) {
                    // Generate the increment block's instructions
                    if (self.visited_blocks.get(block.label) == null) {
                        try self.visited_blocks.put(self.allocator, block.label, {});
                        for (block.instructions.items) |inst| {
                            try self.generateInstruction(inst);
                        }
                    }
                    // The increment block branches to the condition block
                    // Generate the condition block's instructions to re-evaluate the condition
                    if (block.terminator) |inc_term| {
                        switch (inc_term) {
                            .br => |cond_block| {
                                // Generate the condition block's instructions
                                for (cond_block.instructions.items) |inst| {
                                    try self.generateInstruction(inst);
                                }
                                // Don't generate the terminator - the while loop handles it
                            },
                            else => {},
                        }
                    }
                    return;
                }
                
                // Check if already visited (merge point)
                if (self.visited_blocks.get(block.label) != null) {
                    // Already visited - this is a merge point, just return
                    return;
                }
                
                try self.visited_blocks.put(self.allocator, block.label, {});
                
                // Generate the target block's instructions inline
                for (block.instructions.items) |inst| {
                    try self.generateInstruction(inst);
                }
                // Generate the target block's terminator
                if (block.terminator) |target_term| {
                    try self.generateTerminator(target_term);
                }
            },
            .cond_br => |cb| {
                // Detect if this is a loop condition by checking if the block label starts with loop-related prefixes
                const is_loop = self.isLoopCondition(cb.then_block);
                
                if (is_loop) {
                    // This is a loop - we need to generate a while(true) with condition re-evaluation
                    const exit_label: []const u8 = cb.else_block.label;
                    
                    // Find the increment block and condition block for this loop
                    // For a for loop: body -> for_loop (increment) -> for_cond (this block)
                    // For a while loop: body -> while_cond (this block)
                    // For nested loops: body -> inner_loop_cond (different block, handle separately)
                    var increment_block: ?*const IR.BasicBlock = null;
                    var cond_block: ?*const IR.BasicBlock = null;
                    
                    // Check if the body directly branches to a for_loop block (increment)
                    if (cb.then_block.terminator) |then_term| {
                        switch (then_term) {
                            .br => |next| {
                                if (std.mem.startsWith(u8, next.label, "for_loop")) {
                                    // For loop - the loop block is the increment
                                    increment_block = next;
                                    // The increment block branches to the condition block
                                    if (next.terminator) |inc_term| {
                                        switch (inc_term) {
                                            .br => |cond| {
                                                cond_block = cond;
                                            },
                                            else => {},
                                        }
                                    }
                                } else if (std.mem.startsWith(u8, next.label, "while_cond") or
                                    std.mem.startsWith(u8, next.label, "foreach_cond") or
                                    std.mem.startsWith(u8, next.label, "range_cond"))
                                {
                                    // While loop - body branches directly to condition
                                    cond_block = next;
                                }
                            },
                            else => {},
                        }
                    }
                    
                    // For nested for loops, we need to find the increment block differently
                    // The body branches to the inner loop's condition, and the inner loop's exit
                    // branches to the outer loop's increment. We'll find it by looking at the
                    // exit block's terminator chain.
                    if (increment_block == null) {
                        // Try to find the increment block by following the exit path
                        // The exit block might branch to the increment block
                        var current_exit = cb.else_block;
                        var depth: u32 = 0;
                        while (depth < 10) : (depth += 1) {
                            if (current_exit.terminator) |exit_term| {
                                switch (exit_term) {
                                    .br => |next| {
                                        if (std.mem.startsWith(u8, next.label, "for_loop")) {
                                            increment_block = next;
                                            if (next.terminator) |inc_term| {
                                                switch (inc_term) {
                                                    .br => |cond| {
                                                        cond_block = cond;
                                                    },
                                                    else => {},
                                                }
                                            }
                                            break;
                                        }
                                        // Continue following the chain
                                        current_exit = next;
                                    },
                                    else => break,
                                }
                            } else {
                                break;
                            }
                        }
                    }
                    
                    // Push loop context - use the exit label for break detection
                    try self.loop_stack.append(self.allocator, .{
                        .cond_label = if (cond_block) |c| c.label else "",
                        .exit_label = exit_label,
                    });
                    
                    // Generate a while(true) loop
                    try self.writeIndent();
                    try self.writeLine("while (true) {");
                    self.indent_level += 1;

                    // Check condition at the start (using the current condition register)
                    try self.writeIndent();
                    try self.write("if (!runtime.php_value_to_bool(r");
                    try self.writeInt(cb.cond.id);
                    try self.writeLine(")) break;");

                    // Generate the loop body (then_block)
                    if (self.visited_blocks.get(cb.then_block.label) == null) {
                        try self.visited_blocks.put(self.allocator, cb.then_block.label, {});
                        for (cb.then_block.instructions.items) |inst| {
                            try self.generateInstruction(inst);
                        }
                        // Handle the body's terminator
                        if (cb.then_block.terminator) |body_term| {
                            switch (body_term) {
                                .br => |next| {
                                    if (std.mem.startsWith(u8, next.label, "for_loop")) {
                                        // Branch to increment block - handled below
                                    } else if (std.mem.startsWith(u8, next.label, "while_cond") or
                                        std.mem.startsWith(u8, next.label, "foreach_cond") or
                                        std.mem.startsWith(u8, next.label, "range_cond"))
                                    {
                                        // Branch to condition block - this is a continue, handled by while loop
                                    } else if (std.mem.startsWith(u8, next.label, "for_cond")) {
                                        // Branch to a for_cond - could be nested loop or this loop
                                        // Generate it to handle nested loops
                                        try self.generateTerminator(body_term);
                                    } else {
                                        // Other branch - generate it
                                        try self.generateTerminator(body_term);
                                    }
                                },
                                .cond_br => {
                                    // Nested conditional (could be nested loop or if inside loop)
                                    try self.generateTerminator(body_term);
                                },
                                else => {},
                            }
                        }
                    }
                    
                    // Generate increment block if present (for loops)
                    if (increment_block) |inc_block| {
                        if (self.visited_blocks.get(inc_block.label) == null) {
                            try self.visited_blocks.put(self.allocator, inc_block.label, {});
                            for (inc_block.instructions.items) |inst| {
                                try self.generateInstruction(inst);
                            }
                        }
                    }
                    
                    // Re-evaluate the condition at the end of the loop
                    // Generate the condition block's instructions to update the condition register
                    if (cond_block) |cond_blk| {
                        for (cond_blk.instructions.items) |inst| {
                            try self.generateInstruction(inst);
                        }
                    }

                    self.indent_level -= 1;
                    try self.writeIndent();
                    try self.writeLine("}");

                    // Pop loop context
                    _ = self.loop_stack.pop();

                    // After the loop, continue with the else block (exit)
                    if (self.visited_blocks.get(cb.else_block.label) == null) {
                        try self.visited_blocks.put(self.allocator, cb.else_block.label, {});
                        for (cb.else_block.instructions.items) |inst| {
                            try self.generateInstruction(inst);
                        }
                        if (cb.else_block.terminator) |else_term| {
                            try self.generateTerminator(else_term);
                        }
                    }
                } else {
                    // Regular if/else - use the new helper that handles elseif chains properly
                    try self.generateIfElseWithMerge(cb, false);
                }
            },
            .unreachable_ => {
                try self.writeIndent();
                try self.writeLine("unreachable;");
            },
            .throw => |reg| {
                try self.writeIndent();
                try self.write("// throw r");
                try self.writeInt(reg.id);
                try self.writeLine("");
                try self.writeIndent();
                try self.writeLine("unreachable;");
            },
            .switch_ => |sw| {
                try self.writeIndent();
                try self.write("switch (runtime.php_value_to_int(r");
                try self.writeInt(sw.value.id);
                try self.writeLine(")) {");
                self.indent_level += 1;
                for (sw.cases) |case| {
                    try self.writeIndent();
                    try self.writeInt(@intCast(case.value));
                    try self.write(" => {");
                    try self.writeLine("");
                    self.indent_level += 1;
                    // Inline the case block's code if not visited
                    if (self.visited_blocks.get(case.block.label) == null) {
                        try self.visited_blocks.put(self.allocator, case.block.label, {});
                        for (case.block.instructions.items) |inst| {
                            try self.generateInstruction(inst);
                        }
                        if (case.block.terminator) |case_term| {
                            try self.generateTerminator(case_term);
                        }
                    }
                    self.indent_level -= 1;
                    try self.writeIndent();
                    try self.writeLine("},");
                }
                try self.writeIndent();
                try self.write("else => {");
                try self.writeLine("");
                self.indent_level += 1;
                // Inline the default block's code if not visited
                if (self.visited_blocks.get(sw.default.label) == null) {
                    try self.visited_blocks.put(self.allocator, sw.default.label, {});
                    for (sw.default.instructions.items) |inst| {
                        try self.generateInstruction(inst);
                    }
                    if (sw.default.terminator) |default_term| {
                        try self.generateTerminator(default_term);
                    }
                }
                self.indent_level -= 1;
                try self.writeIndent();
                try self.writeLine("},");
                self.indent_level -= 1;
                try self.writeIndent();
                try self.writeLine("}");
            },
        }
    }

    /// Generate terminator for loop body - handles the increment block and continue
    fn generateLoopBodyTerminator(self: *Self, term: IR.Terminator, cond_label: []const u8) !void {
        switch (term) {
            .br => |block| {
                // Check if this is a branch to the loop condition (continue)
                if (std.mem.eql(u8, block.label, cond_label)) {
                    // This is a continue - the while loop will handle re-evaluation
                    return;
                }
                
                // Check if this is a branch to a loop block (for loop increment)
                if (std.mem.startsWith(u8, block.label, "for_loop")) {
                    // Generate the increment instructions
                    if (self.visited_blocks.get(block.label) == null) {
                        try self.visited_blocks.put(self.allocator, block.label, {});
                        for (block.instructions.items) |inst| {
                            try self.generateInstruction(inst);
                        }
                    }
                    // The increment block branches back to condition - handled by while loop
                    return;
                }
                
                // Check if this is a branch to a loop exit (break)
                if (self.isCurrentLoopExit(block.label)) {
                    try self.writeIndent();
                    try self.writeLine("break;");
                    return;
                }
                
                // Otherwise, inline the block
                if (self.visited_blocks.get(block.label) == null) {
                    try self.visited_blocks.put(self.allocator, block.label, {});
                    for (block.instructions.items) |inst| {
                        try self.generateInstruction(inst);
                    }
                    if (block.terminator) |next_term| {
                        try self.generateLoopBodyTerminator(next_term, cond_label);
                    }
                }
            },
            .ret => |val| {
                // Early return from loop
                try self.writeIndent();
                if (val) |reg| {
                    try self.write("return r");
                    try self.writeInt(reg.id);
                    try self.writeLine(";");
                } else {
                    try self.writeLine("return;");
                }
            },
            .cond_br => |cb| {
                // Nested condition in loop body (like break/continue conditions)
                try self.writeIndent();
                try self.write("if (runtime.php_value_to_bool(r");
                try self.writeInt(cb.cond.id);
                try self.writeLine(")) {");
                self.indent_level += 1;
                if (self.visited_blocks.get(cb.then_block.label) == null) {
                    try self.visited_blocks.put(self.allocator, cb.then_block.label, {});
                    for (cb.then_block.instructions.items) |inst| {
                        try self.generateInstruction(inst);
                    }
                    if (cb.then_block.terminator) |then_term| {
                        try self.generateLoopBodyTerminator(then_term, cond_label);
                    }
                }
                self.indent_level -= 1;
                try self.writeIndent();
                try self.writeLine("} else {");
                self.indent_level += 1;
                if (self.visited_blocks.get(cb.else_block.label) == null) {
                    try self.visited_blocks.put(self.allocator, cb.else_block.label, {});
                    for (cb.else_block.instructions.items) |inst| {
                        try self.generateInstruction(inst);
                    }
                    if (cb.else_block.terminator) |else_term| {
                        try self.generateLoopBodyTerminator(else_term, cond_label);
                    }
                }
                self.indent_level -= 1;
                try self.writeIndent();
                try self.writeLine("}");
            },
            else => {
                // For other terminators, generate a comment
                try self.writeIndent();
                try self.writeLine("// Unhandled terminator in loop body");
            },
        }
    }

    // ========================================================================
    // Constant Generation
    // ========================================================================

    fn generateConstInt(self: *Self, result: ?IR.Register, val: i64) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_int(");
            try self.writeInt(val);
            try self.writeLine(");");
        }
    }

    fn generateConstFloat(self: *Self, result: ?IR.Register, val: f64) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_float(");
            try self.writeFloat(val);
            try self.writeLine(");");
        }
    }

    fn generateConstBool(self: *Self, result: ?IR.Register, val: bool) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_bool(");
            try self.write(if (val) "true" else "false");
            try self.writeLine(");");
        }
    }

    fn generateConstString(self: *Self, result: ?IR.Register, string_id: u32) !void {
        if (result) |reg| {
            // Get the string from the module's string table
            const str = if (self.current_module) |m| m.getString(string_id) else null;
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_string(");
            if (str) |s| {
                try self.writeStringLiteral(s);
            } else {
                try self.write("\"\"");
            }
            try self.writeLine(");");
        }
    }

    fn generateConstNull(self: *Self, result: ?IR.Register) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.writeLine(" = runtime.php_value_create_null();");
        }
    }

    // ========================================================================
    // Binary and Unary Operations
    // ========================================================================

    fn generateBinaryOp(self: *Self, result: ?IR.Register, func_name: []const u8, op: IR.Instruction.BinaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.");
            try self.write(func_name);
            try self.write("(r");
            try self.writeInt(op.lhs.id);
            try self.write(", r");
            try self.writeInt(op.rhs.id);
            try self.writeLine(");");
        }
    }

    fn generateUnaryOp(self: *Self, result: ?IR.Register, func_name: []const u8, op: IR.Instruction.UnaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.");
            try self.write(func_name);
            try self.write("(r");
            try self.writeInt(op.operand.id);
            try self.writeLine(");");
        }
    }

    // ========================================================================
    // Logical Operations
    // ========================================================================

    fn generateLogicalAnd(self: *Self, result: ?IR.Register, op: IR.Instruction.BinaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_bool(runtime.php_value_to_bool(r");
            try self.writeInt(op.lhs.id);
            try self.write(") and runtime.php_value_to_bool(r");
            try self.writeInt(op.rhs.id);
            try self.writeLine("));");
        }
    }

    fn generateLogicalOr(self: *Self, result: ?IR.Register, op: IR.Instruction.BinaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_bool(runtime.php_value_to_bool(r");
            try self.writeInt(op.lhs.id);
            try self.write(") or runtime.php_value_to_bool(r");
            try self.writeInt(op.rhs.id);
            try self.writeLine("));");
        }
    }

    fn generateLogicalNot(self: *Self, result: ?IR.Register, op: IR.Instruction.UnaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_bool(!runtime.php_value_to_bool(r");
            try self.writeInt(op.operand.id);
            try self.writeLine("));");
        }
    }

    // ========================================================================
    // String Operations
    // ========================================================================

    fn generateStrlen(self: *Self, result: ?IR.Register, op: IR.Instruction.UnaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_int(runtime.php_string_length(r");
            try self.writeInt(op.operand.id);
            try self.writeLine("));");
        }
    }

    // ========================================================================
    // Array Operations
    // ========================================================================

    fn generateArrayNew(self: *Self, result: ?IR.Register, op: IR.Instruction.ArrayNewOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.writeLine(" = runtime.php_value_create_array();");
            _ = op; // capacity hint not used in simple implementation
        }
    }

    fn generateArrayGet(self: *Self, result: ?IR.Register, op: IR.Instruction.ArrayGetOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_array_get(r");
            try self.writeInt(op.array.id);
            try self.write(".data.array_ptr.?, r");
            try self.writeInt(op.key.id);
            try self.writeLine(");");
        }
    }

    fn generateArraySet(self: *Self, op: IR.Instruction.ArraySetOp) !void {
        try self.write("runtime.php_array_set(r");
        try self.writeInt(op.array.id);
        try self.write(".data.array_ptr.?, r");
        try self.writeInt(op.key.id);
        try self.write(", r");
        try self.writeInt(op.value.id);
        try self.writeLine(");");
    }

    fn generateArrayPush(self: *Self, op: IR.Instruction.ArrayPushOp) !void {
        try self.write("runtime.php_array_push(r");
        try self.writeInt(op.array.id);
        try self.write(".data.array_ptr.?, r");
        try self.writeInt(op.value.id);
        try self.writeLine(");");
    }

    fn generateArrayCount(self: *Self, result: ?IR.Register, op: IR.Instruction.UnaryOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = runtime.php_value_create_int(runtime.php_array_count(r");
            try self.writeInt(op.operand.id);
            try self.writeLine(".data.array_ptr.?));");
        }
    }

    // ========================================================================
    // Function Calls
    // ========================================================================

    fn generateCall(self: *Self, result: ?IR.Register, op: IR.Instruction.CallOp) !void {
        // Check for built-in functions
        if (self.isBuiltinFunction(op.func_name)) {
            try self.generateBuiltinCall(result, op);
            return;
        }

        // Look up the function to get parameter info for default values
        const func = if (self.current_module) |module| module.findFunction(op.func_name) else null;
        const param_count = if (func) |f| f.params.items.len else op.args.len;

        // User-defined function call
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = ");
        }
        try self.writeFunctionName(op.func_name);
        try self.write("(");

        // Generate arguments, filling in defaults for missing ones
        for (0..param_count) |i| {
            if (i > 0) try self.write(", ");

            if (i < op.args.len) {
                // Use provided argument
                try self.write("r");
                try self.writeInt(op.args[i].id);
            } else if (func) |f| {
                // Use default value
                if (i < f.params.items.len) {
                    const param = f.params.items[i];
                    if (param.default_value) |default| {
                        try self.writeDefaultValue(default);
                    } else {
                        // No default, use null
                        try self.write("runtime.php_value_create_null()");
                    }
                } else {
                    try self.write("runtime.php_value_create_null()");
                }
            } else {
                try self.write("runtime.php_value_create_null()");
            }
        }
        try self.writeLine(");");
    }

    /// Write a default value as a runtime value creation call
    fn writeDefaultValue(self: *Self, default: IR.DefaultValue) !void {
        switch (default) {
            .int => |val| {
                try self.write("runtime.php_value_create_int(");
                try self.writeInt(val);
                try self.write(")");
            },
            .float => |val| {
                try self.write("runtime.php_value_create_float(");
                try self.writeFloat(val);
                try self.write(")");
            },
            .bool_ => |val| {
                try self.write("runtime.php_value_create_bool(");
                try self.write(if (val) "true" else "false");
                try self.write(")");
            },
            .string => |val| {
                try self.write("runtime.php_value_create_string(");
                try self.writeStringLiteral(val);
                try self.write(")");
            },
            .null_ => {
                try self.write("runtime.php_value_create_null()");
            },
        }
    }

    fn isBuiltinFunction(self: *Self, name: []const u8) bool {
        _ = self;
        const builtins = [_][]const u8{
            "echo",       "print",       "var_dump",    "print_r",
            "php_echo",   "php_print",   "php_var_dump", "php_print_r",
            "strlen",     "substr",      "strpos",      "str_replace",
            "php_strlen", "php_substr",  "php_strpos",  "php_str_replace",
            "count",      "array_push",  "array_pop",   "array_keys",   "array_values",
            "php_count",  "php_array_push", "php_array_pop", "php_array_keys", "php_array_values",
            "isset",      "empty",       "unset",
            "php_isset",  "php_empty",   "php_unset",
            "gettype",    "is_null",     "is_bool",     "is_int",       "is_float",     "is_string",    "is_array",
            "php_gettype", "php_is_null", "php_is_bool", "php_is_int",  "php_is_float", "php_is_string", "php_is_array",
        };
        for (builtins) |builtin| {
            if (std.mem.eql(u8, name, builtin)) return true;
        }
        return false;
    }

    fn generateBuiltinCall(self: *Self, result: ?IR.Register, op: IR.Instruction.CallOp) !void {
        if (std.mem.eql(u8, op.func_name, "echo") or std.mem.eql(u8, op.func_name, "php_echo")) {
            // echo doesn't return a value
            for (op.args, 0..) |arg, i| {
                if (i > 0) try self.writeIndent();
                try self.write("runtime.php_echo(r");
                try self.writeInt(arg.id);
                try self.writeLine(");");
            }
            return;
        }

        if (std.mem.eql(u8, op.func_name, "print") or std.mem.eql(u8, op.func_name, "php_print")) {
            if (result) |reg| {
                try self.write("r");
                try self.writeInt(reg.id);
                try self.write(" = runtime.php_value_create_int(runtime.php_print(r");
                if (op.args.len > 0) {
                    try self.writeInt(op.args[0].id);
                }
                try self.writeLine("));");
            } else if (op.args.len > 0) {
                try self.write("_ = runtime.php_print(r");
                try self.writeInt(op.args[0].id);
                try self.writeLine(");");
            }
            return;
        }

        if (std.mem.eql(u8, op.func_name, "strlen") or std.mem.eql(u8, op.func_name, "php_strlen")) {
            if (result) |reg| {
                try self.write("r");
                try self.writeInt(reg.id);
                try self.write(" = runtime.php_value_create_int(runtime.php_string_length(r");
                if (op.args.len > 0) {
                    try self.writeInt(op.args[0].id);
                }
                try self.writeLine("));");
            }
            return;
        }

        if (std.mem.eql(u8, op.func_name, "count") or std.mem.eql(u8, op.func_name, "php_count")) {
            if (result) |reg| {
                try self.write("r");
                try self.writeInt(reg.id);
                try self.write(" = runtime.php_value_create_int(@intCast(r");
                if (op.args.len > 0) {
                    try self.writeInt(op.args[0].id);
                    try self.write(".data.array_ptr.?.count()");
                }
                try self.writeLine("));");
            }
            return;
        }

        if (std.mem.eql(u8, op.func_name, "var_dump") or std.mem.eql(u8, op.func_name, "php_var_dump")) {
            for (op.args, 0..) |arg, i| {
                if (i > 0) try self.writeIndent();
                try self.write("runtime.php_var_dump(r");
                try self.writeInt(arg.id);
                try self.writeLine(");");
            }
            return;
        }

        if (std.mem.eql(u8, op.func_name, "gettype") or std.mem.eql(u8, op.func_name, "php_gettype")) {
            if (result) |reg| {
                try self.write("r");
                try self.writeInt(reg.id);
                try self.write(" = runtime.php_value_create_string(runtime.php_value_get_type_name(r");
                if (op.args.len > 0) {
                    try self.writeInt(op.args[0].id);
                }
                try self.writeLine("));");
            }
            return;
        }

        // Default: generate a comment for unimplemented builtins
        try self.write("// TODO: builtin ");
        try self.write(op.func_name);
        try self.writeLine("");
    }

    // ========================================================================
    // Memory Operations
    // ========================================================================

    fn generateRetain(self: *Self, op: IR.Instruction.UnaryOp) !void {
        try self.write("runtime.php_gc_retain(r");
        try self.writeInt(op.operand.id);
        try self.writeLine(");");
    }

    fn generateRelease(self: *Self, op: IR.Instruction.UnaryOp) !void {
        try self.write("runtime.php_gc_release(r");
        try self.writeInt(op.operand.id);
        try self.writeLine(");");
    }

    fn generateAlloca(self: *Self, result: ?IR.Register, op: IR.Instruction.AllocaOp) !void {
        // In Zig, we simulate alloca by using the register as a variable
        // The register already holds a *PHPValue, so alloca just initializes it to null
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.writeLine(" = runtime.php_value_create_null();");
        }
        _ = op; // type info not needed for simple implementation
    }

    fn generateStore(self: *Self, op: IR.Instruction.StoreOp) !void {
        // Store value into the pointer (register)
        // In our simplified model, we just copy the value reference
        try self.write("r");
        try self.writeInt(op.ptr.id);
        try self.write(" = r");
        try self.writeInt(op.value.id);
        try self.writeLine(";");
    }

    fn generateLoad(self: *Self, result: ?IR.Register, op: IR.Instruction.LoadOp) !void {
        // Load value from the pointer (register)
        // In our simplified model, we just copy the value reference
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = r");
            try self.writeInt(op.ptr.id);
            try self.writeLine(";");
        }
    }

    // ========================================================================
    // Box/Unbox Operations
    // ========================================================================

    fn generateBox(self: *Self, result: ?IR.Register, op: IR.Instruction.BoxOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = ");

            switch (op.from_type) {
                .i64 => {
                    try self.write("runtime.php_value_create_int(@intCast(r");
                    try self.writeInt(op.value.id);
                    try self.writeLine("));");
                },
                .f64 => {
                    try self.write("runtime.php_value_create_float(r");
                    try self.writeInt(op.value.id);
                    try self.writeLine(");");
                },
                .bool => {
                    try self.write("runtime.php_value_create_bool(r");
                    try self.writeInt(op.value.id);
                    try self.writeLine(");");
                },
                else => {
                    try self.write("r");
                    try self.writeInt(op.value.id);
                    try self.writeLine("; // passthrough");
                },
            }
        }
    }

    fn generateUnbox(self: *Self, result: ?IR.Register, op: IR.Instruction.UnboxOp) !void {
        if (result) |reg| {
            try self.write("r");
            try self.writeInt(reg.id);
            try self.write(" = ");

            switch (op.to_type) {
                .i64 => {
                    try self.write("runtime.php_value_to_int(r");
                    try self.writeInt(op.value.id);
                    try self.writeLine(");");
                },
                .f64 => {
                    try self.write("runtime.php_value_to_float(r");
                    try self.writeInt(op.value.id);
                    try self.writeLine(");");
                },
                .bool => {
                    try self.write("runtime.php_value_to_bool(r");
                    try self.writeInt(op.value.id);
                    try self.writeLine(");");
                },
                else => {
                    try self.write("r");
                    try self.writeInt(op.value.id);
                    try self.writeLine("; // passthrough");
                },
            }
        }
    }

    // ========================================================================
    // Main Entry Point Generation
    // ========================================================================

    fn generateMainEntry(self: *Self, module: *const IR.Module) !void {
        try self.writeLine("// Main entry point");
        try self.writeLine("pub fn main() !void {");
        self.indent_level += 1;

        try self.writeIndent();
        try self.writeLine("// Initialize runtime");
        try self.writeIndent();
        try self.writeLine("runtime.initRuntime();");
        try self.writeIndent();
        try self.writeLine("defer runtime.deinitRuntime();");
        try self.writeLine("");

        // Call the main PHP function if it exists
        if (module.findFunction("main")) |_| {
            try self.writeIndent();
            try self.writeLine("// Execute PHP main");
            try self.writeIndent();
            try self.writeLine("_ = php_main();");
        } else if (module.findFunction("__main__")) |_| {
            try self.writeIndent();
            try self.writeLine("// Execute PHP main");
            try self.writeIndent();
            try self.writeLine("_ = php___main__();");
        } else if (module.functions.items.len > 0) {
            // Call the first function as main
            try self.writeIndent();
            try self.writeLine("// Execute first function as main");
            try self.writeIndent();
            try self.write("_ = ");
            try self.writeFunctionName(module.functions.items[0].name);
            try self.writeLine("();");
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    // ========================================================================
    // Helper Functions
    // ========================================================================

    /// Sanitize a PHP variable name for use in Zig code
    /// Removes the leading $ and replaces invalid characters with _
    fn sanitizeVarName(self: *Self, name: []const u8) !void {
        // Skip leading $ if present
        const start: usize = if (name.len > 0 and name[0] == '$') 1 else 0;
        
        // If name is empty after removing $, use a default
        if (start >= name.len) {
            try self.write("_var");
            return;
        }
        
        // Write sanitized name
        for (name[start..]) |c| {
            if (std.ascii.isAlphanumeric(c) or c == '_') {
                try self.output.append(self.allocator, c);
            } else {
                try self.output.append(self.allocator, '_');
            }
        }
    }

    fn writeFunctionName(self: *Self, name: []const u8) !void {
        try self.write("php_");
        // Sanitize function name for Zig
        for (name) |c| {
            if (std.ascii.isAlphanumeric(c) or c == '_') {
                try self.output.append(self.allocator, c);
            } else {
                try self.output.append(self.allocator, '_');
            }
        }
    }

    fn writeType(self: *Self, t: IR.Type) !void {
        switch (t) {
            .void => try self.write("void"),
            .bool => try self.write("bool"),
            .i64 => try self.write("i64"),
            .f64 => try self.write("f64"),
            .php_value => try self.write("*PHPValue"),
            .php_string => try self.write("*PHPString"),
            .php_array => try self.write("*PHPArray"),
            else => try self.write("*PHPValue"),
        }
    }

    fn writeStringLiteral(self: *Self, str: []const u8) !void {
        try self.output.append(self.allocator, '"');
        var i: usize = 0;
        while (i < str.len) {
            const c = str[i];
            // Check for escape sequences in the source string
            if (c == '\\' and i + 1 < str.len) {
                const next = str[i + 1];
                switch (next) {
                    'n' => {
                        try self.write("\\n");
                        i += 2;
                        continue;
                    },
                    'r' => {
                        try self.write("\\r");
                        i += 2;
                        continue;
                    },
                    't' => {
                        try self.write("\\t");
                        i += 2;
                        continue;
                    },
                    '\\' => {
                        try self.write("\\\\");
                        i += 2;
                        continue;
                    },
                    '"' => {
                        try self.write("\\\"");
                        i += 2;
                        continue;
                    },
                    '\'' => {
                        try self.write("\\'");
                        i += 2;
                        continue;
                    },
                    '$' => {
                        try self.write("$");
                        i += 2;
                        continue;
                    },
                    else => {
                        // Unknown escape sequence, output as-is
                        try self.write("\\\\");
                        i += 1;
                        continue;
                    },
                }
            }
            switch (c) {
                '\n' => try self.write("\\n"),
                '\r' => try self.write("\\r"),
                '\t' => try self.write("\\t"),
                '\\' => try self.write("\\\\"),
                '"' => try self.write("\\\""),
                else => {
                    if (c >= 32 and c < 127) {
                        try self.output.append(self.allocator, c);
                    } else {
                        try self.write("\\x");
                        const hex = "0123456789abcdef";
                        try self.output.append(self.allocator, hex[c >> 4]);
                        try self.output.append(self.allocator, hex[c & 0xf]);
                    }
                },
            }
            i += 1;
        }
        try self.output.append(self.allocator, '"');
    }

    fn writeInt(self: *Self, val: i64) !void {
        var buf: [32]u8 = undefined;
        const result = std.fmt.bufPrint(&buf, "{d}", .{val}) catch return;
        try self.write(result);
    }

    fn writeFloat(self: *Self, val: f64) !void {
        var buf: [64]u8 = undefined;
        const result = std.fmt.bufPrint(&buf, "{d}", .{val}) catch return;
        try self.write(result);
    }

    fn write(self: *Self, str: []const u8) !void {
        try self.output.appendSlice(self.allocator, str);
    }

    fn writeLine(self: *Self, str: []const u8) !void {
        try self.output.appendSlice(self.allocator, str);
        try self.output.append(self.allocator, '\n');
    }

    fn writeIndent(self: *Self) !void {
        for (0..self.indent_level) |_| {
            try self.output.appendSlice(self.allocator, "    ");
        }
    }

    /// Get the generated output as a slice (without transferring ownership)
    pub fn getOutput(self: *const Self) []const u8 {
        return self.output.items;
    }

    /// Reset the generator state for reuse
    pub fn reset(self: *Self) void {
        self.output.clearRetainingCapacity();
        self.runtime_imports.clearRetainingCapacity();
        self.block_labels.clearRetainingCapacity();
        self.declared_registers.clearRetainingCapacity();
        self.loop_stack.clearRetainingCapacity();
        self.label_counter = 0;
        self.current_module = null;
    }
};

// ============================================================================
// Unit Tests
// ============================================================================

test "ZigCodeGenerator initialization" {
    const allocator = std.testing.allocator;
    var gen = ZigCodeGenerator.init(allocator, null);
    defer gen.deinit();

    try std.testing.expectEqual(@as(u32, 0), gen.indent_level);
    try std.testing.expectEqual(@as(usize, 0), gen.output.items.len);
}

test "ZigCodeGenerator simple module generation" {
    const allocator = std.testing.allocator;

    // Create a simple IR module
    var module = IR.Module.init(allocator, "test", "test.php");
    defer module.deinit();

    // Create a simple function
    const func = try allocator.create(IR.Function);
    func.* = IR.Function.init(allocator, "main");
    func.return_type = .php_value;
    try module.addFunction(func);

    // Add entry block
    const entry = try func.createBlock("entry");

    // Add a constant instruction
    const const_inst = try allocator.create(IR.Instruction);
    const_inst.* = .{
        .result = func.newRegister(.php_value),
        .op = .{ .const_int = 42 },
        .location = .{},
    };
    try entry.appendInstruction(const_inst);

    // Add return
    entry.setTerminator(.{ .ret = const_inst.result });

    // Generate code
    var gen = ZigCodeGenerator.init(allocator, null);
    defer gen.deinit();

    const code = try gen.generate(&module);
    defer allocator.free(code);

    // Verify output contains expected elements
    try std.testing.expect(std.mem.indexOf(u8, code, "const runtime = @import(\"runtime_lib.zig\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "fn php_main") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "php_value_create_int(42)") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn main()") != null);
}

test "ZigCodeGenerator arithmetic operations" {
    const allocator = std.testing.allocator;

    var module = IR.Module.init(allocator, "arith", "arith.php");
    defer module.deinit();

    const func = try allocator.create(IR.Function);
    func.* = IR.Function.init(allocator, "add_test");
    func.return_type = .php_value;
    try module.addFunction(func);

    const entry = try func.createBlock("entry");

    // Create two constants
    const r0 = func.newRegister(.php_value);
    const inst0 = try allocator.create(IR.Instruction);
    inst0.* = .{
        .result = r0,
        .op = .{ .const_int = 10 },
        .location = .{},
    };
    try entry.appendInstruction(inst0);

    const r1 = func.newRegister(.php_value);
    const inst1 = try allocator.create(IR.Instruction);
    inst1.* = .{
        .result = r1,
        .op = .{ .const_int = 20 },
        .location = .{},
    };
    try entry.appendInstruction(inst1);

    // Add them
    const r2 = func.newRegister(.php_value);
    const add_inst = try allocator.create(IR.Instruction);
    add_inst.* = .{
        .result = r2,
        .op = .{ .add = .{ .lhs = r0, .rhs = r1 } },
        .location = .{},
    };
    try entry.appendInstruction(add_inst);

    entry.setTerminator(.{ .ret = r2 });

    var gen = ZigCodeGenerator.init(allocator, null);
    defer gen.deinit();

    const code = try gen.generate(&module);
    defer allocator.free(code);

    // Verify arithmetic operation
    try std.testing.expect(std.mem.indexOf(u8, code, "php_add") != null);
}

test "ZigCodeGenerator string literal escaping" {
    const allocator = std.testing.allocator;

    var module = IR.Module.init(allocator, "string", "string.php");
    defer module.deinit();

    // Intern a string with special characters
    const str_id = try module.internString("Hello\nWorld\t\"Test\"");

    const func = try allocator.create(IR.Function);
    func.* = IR.Function.init(allocator, "string_test");
    func.return_type = .php_value;
    try module.addFunction(func);

    const entry = try func.createBlock("entry");

    const r0 = func.newRegister(.php_value);
    const inst = try allocator.create(IR.Instruction);
    inst.* = .{
        .result = r0,
        .op = .{ .const_string = str_id },
        .location = .{},
    };
    try entry.appendInstruction(inst);

    entry.setTerminator(.{ .ret = r0 });

    var gen = ZigCodeGenerator.init(allocator, null);
    defer gen.deinit();

    const code = try gen.generate(&module);
    defer allocator.free(code);

    // Verify escaped string
    try std.testing.expect(std.mem.indexOf(u8, code, "\\n") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "\\t") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "\\\"") != null);
}

test "ZigCodeGenerator comparison operations" {
    const allocator = std.testing.allocator;

    var module = IR.Module.init(allocator, "compare", "compare.php");
    defer module.deinit();

    const func = try allocator.create(IR.Function);
    func.* = IR.Function.init(allocator, "compare_test");
    func.return_type = .php_value;
    try module.addFunction(func);

    const entry = try func.createBlock("entry");

    const r0 = func.newRegister(.php_value);
    const inst0 = try allocator.create(IR.Instruction);
    inst0.* = .{
        .result = r0,
        .op = .{ .const_int = 5 },
        .location = .{},
    };
    try entry.appendInstruction(inst0);

    const r1 = func.newRegister(.php_value);
    const inst1 = try allocator.create(IR.Instruction);
    inst1.* = .{
        .result = r1,
        .op = .{ .const_int = 10 },
        .location = .{},
    };
    try entry.appendInstruction(inst1);

    const r2 = func.newRegister(.php_value);
    const lt_inst = try allocator.create(IR.Instruction);
    lt_inst.* = .{
        .result = r2,
        .op = .{ .lt = .{ .lhs = r0, .rhs = r1 } },
        .location = .{},
    };
    try entry.appendInstruction(lt_inst);

    entry.setTerminator(.{ .ret = r2 });

    var gen = ZigCodeGenerator.init(allocator, null);
    defer gen.deinit();

    const code = try gen.generate(&module);
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "php_lt") != null);
}
